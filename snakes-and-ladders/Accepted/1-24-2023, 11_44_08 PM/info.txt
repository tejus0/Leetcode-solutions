{"id":884534609,"lang":"cpp","lang_name":"C++","time":"12 hours, 57 minutes","timestamp":1674584048,"status":10,"status_display":"Accepted","runtime":"24 ms","url":"/submissions/detail/884534609/","is_pending":"Not Pending","title":"Snakes and Ladders","memory":"12.9 MB","code":"class Solution {\npublic:\n    pair<int,int> help(int next, int n){\n        pair<int,int> cords;   // To store the cords\n        int r = n - (next - 1) / n - 1;  // Formula for the rows\n        int c = (next - 1) % n;  // Formula for diff parity of rows and n\n\n        if(r % 2 == n % 2) { c = n - 1 - c; }  // If parity is same then sub (n - 1)\n        cords.first= r;   // Pushing col in vector\n        cords.second=c;\n\n        return cords;  // Return the cords\n    }\n\n    int snakesAndLadders(vector<vector<int>>& board) {\n        int n = size(board);  //Size\n        queue<int> q;   //For BFS\n        vector<int> visited(n * n + 1);  //visited vector\n        int ans = 0;  //Minimum no. of steps\n\n        q.push(1);  //Initially we are at 1st box\n        visited[1] = 1;   //Marking 1st box as visited\n\n        while(!q.empty()){   //Starting BFS\n            int m = q.size();   //Size of Curr queue\n\n            for(int i = 0; i < m; i++){   //Loop of visiting further nodes from the nodes present in queue\n                int t = q.front();   //First Element\n                q.pop();\n                if(t == n * n) { return ans; }   //If we get the last element then return ans\n\n                for(int j = 1; j < 7; ++j){  //Loop for all possible values of die\n                    if(t + j > n * n) { break; }  //If adding any possibility of die exceeds the limit of board then break\n                    if(visited[t + j]) { continue; }  // IF already visited then continue\n                    visited[t + j] = 1;  //Marking the node as visited\n\n                    pair<int,int> cords = help(t + j, n);  //Function to find the cords of the present node\n                    int r = cords.first;   //Row no. where node is present \n                    int c = cords.second;   //Column no. where node is present\n\n                    if(board[r][c] == -1) { q.push(t + j); }  // if the board has -1 then there is no jump and push the possibilty generated by die\n                    else { q.push(board[r][c]); }  // Else push that jump caused by snake or ladder\n                }\n            }\n\n            ans++;   //counting the steps\n        }\n\n        return -1;   //FINAL ANSWER if it is not possible to visit the last element\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"snakes-and-ladders","has_notes":false}