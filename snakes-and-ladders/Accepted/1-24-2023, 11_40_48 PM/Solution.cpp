// https://leetcode.com/problems/snakes-and-ladders

class Solution {
public:
    vector<int> help(int next, int n){
        vector<int> cords;   // To store the cords
        int r = n - (next - 1) / n - 1;  // Formula for the rows
        int c = (next - 1) % n;  // Formula for diff parity of rows and n

        if(r % 2 == n % 2) { c = n - 1 - c; }  // If parity is same then sub (n - 1)
        cords.push_back(r);   // Pushing row in vector
        cords.push_back(c);   // Pushing col in vector

        return cords;  // Return the cords
    }

    int snakesAndLadders(vector<vector<int>>& board) {
        int n = size(board);  //Size
        queue<int> q;   //For BFS
        vector<int> visited(n * n + 1);  //visited vector
        int ans = 0;  //Minimum no. of steps

        q.push(1);  //Initially we are at 1st box
        visited[1] = 1;   //Marking 1st box as visited

        while(!q.empty()){   //Starting BFS
            int m = q.size();   //Size of Curr queue

            for(int i = 0; i < m; i++){   //Loop of visiting further nodes from the nodes present in queue
                int t = q.front();   //First Element
                q.pop();
                if(t == n * n) { return ans; }   //If we get the last element then return ans

                for(int j = 1; j < 7; ++j){  //Loop for all possible values of die
                    if(t + j > n * n) { break; }  //If adding any possibility of die exceeds the limit of board then break
                    if(visited[t + j]) { continue; }  // IF already visited then continue
                    visited[t + j] = 1;  //Marking the node as visited

                    vector<int> cords = help(t + j, n);  //Function to find the cords of the present node
                    int r = cords[0];   //Row no. where node is present 
                    int c = cords[1];   //Column no. where node is present

                    if(board[r][c] == -1) { q.push(t + j); }  // if the board has -1 then there is no jump and push the possibilty generated by die
                    else { q.push(board[r][c]); }  // Else push that jump caused by snake or ladder
                }
            }

            ans++;   //counting the steps
        }

        return -1;   //FINAL ANSWER if it is not possible to visit the last element
    }
};