{"id":877607113,"lang":"cpp","lang_name":"C++","time":"1 week, 4 days","timestamp":1673635541,"status":10,"status_display":"Accepted","runtime":"95 ms","url":"/submissions/detail/877607113/","is_pending":"Not Pending","title":"Split Array into Consecutive Subsequences","memory":"58.4 MB","code":"class Solution {\npublic:\n    bool isPossible(vector<int>& arr) \n    {\n        //We need 2 hashmaps->\n        //1.available(to store what elements are available)\n        //2.requirement(to store what elements are required by a previous subsequence)\n        unordered_map<int,int>avail,req;\n        //traverse the elements and store the count in the avail map\n        for(auto it:arr)\n            avail[it]++;\n        //traverse the array and check the conditions\n        for(auto it:arr)\n        {\n            if(avail[it]==0)//element is not available to be added in any subseq\n                continue;\n            avail[it]--;\n            //check if the element is required by a previous subseq\n            if(req[it])\n            {\n                //add to the prev subseq\n                req[it]--;\n                req[it+1]++;\n            }\n            //check if we can start a new subseq\n            else if(avail[it+1] && avail[it+2])\n            {\n                avail[it+1]--;\n                avail[it+2]--;\n                req[it+3]++;\n            }\n            //valid subsequence is not possible\n            else\n                return false;\n        }\n        return true;\n        \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"split-array-into-consecutive-subsequences","has_notes":false}